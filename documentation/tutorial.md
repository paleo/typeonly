# Tutorials for TypeOnly

## Parse TypeScript definitions with the CLI

In a new directory, install `typeonly` as a dependency:

```sh
npm init
npm install typeonly --save-dev
```

Edit the file `package.json` and add the following entry in the section `"scripts"`:

```json
  "scripts": {
    "typeonly": "typeonly --bundle dist/types.to.json --source-dir types"
  },
```

Create a subdirectory `types/`, then create a file _"types/drawing.d.ts"_ with the following code:

```ts
// types/drawing.d.ts

export interface Drawing {
  color: ColorName;
  dashed?: boolean;
  shape: Rectangle | Circle;
}

export type ColorName = "red" | "green" | "blue";

export interface Rectangle {
  kind: "rectangle";
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface Circle {
  kind: "circle";
  x: number;
  y: number;
  radius: number;
}
```

Now we can execute the TypeOnly parser via our script:

```sh
npm run typeonly
```

This command creates a file `dist/types.to.json`. A file with the `.to.json` extension is a bundle that contains metadata extracted from several `.d.ts` typing file.

## How to programmatically validate JSON data

Now, add `@typeonly/validator` to the project:

```sh
npm install @typeonly/validator
```

Create a file `src/validate-main.js` with the following content:

```ts
// src/validate-main.js
import { readFileSync } from "node:fs"
import { createValidator } from "@typeonly/validator";

const data = {
  color: "green",
  shape: {
    kind: "circle",
    x: 100,
    y: 100,
    radius: 50
  }
};

const validator = createValidator({
  bundle: JSON.parse(readFileSync(`./types.to.json`));
});
const result = validator.validate("./drawing", "Drawing", data);
console.log(result);
```

This code validates the `data` object using RTO files generated by the TypeOnly parser.

Execute it:

```sh
$ node src/validate-main.js
{ valid: true }
```

## Tutorial: Load typing definitions at runtime

Now, add `@typeonly/loader` to the project:

```sh
npm install @typeonly/loader
```

Create a file `src/main.js` with the following content:

```ts
// src/main.js
import { readFileSync } from "node:fs"
import { loadModules, literals } from "@typeonly/loader";

const modules = loadModules({
  bundle: JSON.parse(readFileSync(`./types.to.json`));
});

const { ColorName } = modules["./drawing"].namedTypes;
console.log("Color names:", literals(ColorName, "string"));
```

If you write this code in a TypeScript source file, simply replace the `require` syntax with a standard `import`.

We can execute our program:

```sh
$ node src/main.js
Color names: [ 'red', 'green', 'blue' ]
```

Yes, itâ€™s as easy as it seems: the list of color names is now available at runtime.

Notice: The TypeOnly parser is used at build time. At runtime, our code only use `@typeonly/loader` which is a lightweight wrapper for `.to.json` files.

## How to validate the conformity of a JSON file using the CLI

Create a file _"drawing.d.ts"_ with the following code:

```ts
// drawing.d.ts

export interface Drawing {
  color: ColorName
  dashed?: boolean
  shape: Rectangle | Circle
}

export type ColorName = "red" | "green" | "blue"

export interface Rectangle {
  kind: "rectangle",
  x: number
  y: number
  width: number
  height: number
}

export interface Circle {
  kind: "circle",
  x: number
  y: number
  radius: number
}
```

Then, create a JSON file _"drawing.json"_ that must be of type `Drawing`:

```json
{
  "color": "green",
  "shape": {
    "kind": "circle",
    "x": 100,
    "y": 100,
    "radius": "wrong value"
  }
}
```

We are ready to validate the JSON file:

```sh
$ npx @typeonly/validator-cli -s drawing.d.ts -t "Drawing" drawing.json
In property 'radius', value '"wrong value"' is not conform to number.
```

A mistake is detected in the JSON file. Fix it by replacing the value of the property `"radius"` with a valid number. For example: `"radius": 50`. And run the command again:

```sh
$ npx @typeonly/validator-cli -s drawing.d.ts -t "Drawing" drawing.json
```

Good. The validator no longer complain.
